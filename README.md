# warmup_project


## Drive in Square 
I am using an approach with python's built in time module, specifically the sleep() function. Essentially, my robot travels forward for some set amount of time and then turns.  

My robot travels forward with an acceleration function "ramp_up", which steps the velocity in the x direction from 0 to the final speed (in this case 0.5) in 0.1 m/s intervals. I also wait 0.5 seconds before incrementing each speed to make the jumps less dramatic. I implemented this because the large jump between 0 and 0.5 m/s caused the robot to drift. The robot still drifts a little bit, but it is far less extreme than it was without it. 

Once the robot has reached its top speed, it continues at that speed for 5 sec. Then, it deccelerates with the "ramp_down" function, which decreases the robot's speed from 0.5 m/s to 0 (stopped) again in 0.1 m/s intervals. Here I wait 1 sec between each decrement, as if the robot is traveling too fast before it stops it tended to undershoot the turn. 

Then, I make the turn by setting the x velocity to 0 and setting the angular velocity to 0.2 (rad/sec). I need to turn 90 degrees, or /pi/2 radians, so if I am turning at 0.2 rad/sec, I need to wait for /pi seconds until I have reached a right angle. Then I set the angular velocity to 0 and the process repeats, and the robot keeps driving in a square.

I was unsure if the robot was supposed to drive in a square once, then stop, or if it was supposed to be continuous. My program at the moment does continuous squares. There is some drift that becomes more and more noticeable with each square the robot completes. Below is a gif of the square path the robot takes. Note that there is still some drifting, as the robot doesn't exactly end up at the origin.

![Driving in a square](DriveInSquare2.gif)



## Wall Follower
My wall follower program essentially tries to keep a wall at the robot's right side. The robot searches for the closest wall with its sensor, turns and travels towards it, and then rotates and travels forward while keeping the wall at its right. It also checks the sensor data directly in front of it to check when it is encountering a corner, and turns left at these occasions. 

The instructions for the robot are held in the FollowWall class. In "init", I subscribe to "/scan" which gives me the sensor data, and set up a publisher to "/cmd_vel" so that I can move the robot. I have a generic "change_speed" helper function which takes in a linear and angular velocity and applies this to the "cmd_vel" publisher. I use this helper function often in my "process_scan"  function which contains the bulk of the logic. I first find the closest wall to the robot as well as it's relative angle. I also keep track of the distance to a wall directly in front of the robot (if it exists). First, I check if this distance in front of the robot is very small, meaning the robot is about to crash, and if it is I stop and rotate the robot to the left. If not, I check if the robot is the appropriate distance from the wall, and if the closest wall is to the right. If it is aligned properly with the wall, I just move forward, and if not, I stop and rotate until it is aligned. If the robot is too far from the wall, I first rotate it so that it faces the wall and then drive it towards the wall. Finally, if the robot is too close to the wall, I rotate it to the left (again stopping if it is about to crash, and moving forward if it is not). In most of the angular adjustments I use proportional control where the error is how far off from the desired angle the robot is. When traveling around the room, the robot drives at a fixed speed. You can see this proportional control in action when the robot drives around the wall, from the red arrow swinging back and forth to try to align itself to be parallel to the wall.  

![Following wall](wallfollower.gif)

## Person Follower
My person follower code uses a very similar approach to my wall follower code. Essentially the robot uses its sensor to locate the object closest to it. Then it rotates towards the object, and once it is roughly facing it, it moves forward and stops a fixed distance away. 

I describe these behaviors in my FollowPerson class. Again, in "init", I subscribe to "/scan" which gives me the sensor data, and set up a publisher to "/cmd_vel" so that I can move the robot. I again have a generic "change_velocity" helper function which takes in a linear and angular velocity and applies this to the "cmd_vel" publisher. My "process_scan" function first finds the closest object to the robot and its relative angle. If a minimum distance can't be found, the robot doesn't move. If the minimum distance is greater than the distance I want my robot to be from the object, I frist rotate the robot so that it is roughly facing the object and then move it forward. I again use proportional control for both the linear and angular components of the robot's velocity, which are proportional to the distance the robot is from the object and the angular offset, respectively. Finally, once the robot is the appropriate distance away, it stops. I try to run through each of these conditions in the gif below. 

![Following person (cylinder)](personfollower.gif)

## Challenges
By far the behavior that gave me the most problems was the wall follower. In particular I ran into a lot of issues with the robot getting stuck in the corners. This was because initially I thought I didn't have to check how far away the wall directly in front of the robot was. This condition is now the first thing that I check for in my successful code. The problem that arose from this was the robot would travel forward along the wall until it was about equidistant from the wall in front of it and the wall to its right. First it would detect that the wall in front of it was the "closest" and would start to turn left. Then during this turn, it would detect that the wall to the right was actually "closest" and would start turning back right. The result was that the robot would be stationary, and would just swing back and forth between the two walls. When I first though to add an explicit check for the wall in front, I only checked if this distance was less than the desired distance to the wall, which still did not solve the problem, because sometimes while the robot was in the process of turning it would still detect that the previous wall was about the same distance away, and the problem would ensue. What finally worked was setting up a mismatch between the distance to the front wall and the distance to the side wall, because once the robot got close enough to the wall in front of it, it would always carry out the "turn left" condition arising from this first if statement. Essentially, how I solved it was a huge amount of trial and error, and placing the robot into different locations in the gazebo room and seeing what sorts of conditions caused this behavior. Another challenge that I encountered was setting the correct robot speed and constants of proportionality for the proportional control. For example, when I was trying to set these for my person follower code, I came across a scenario where the robot would never reach the object but instead run circles around it since both its speed and angular velocity were high. This was before I implemented the code to turn the robot towards the object before sending it forward. I also had issues setting the constants and speed in my wall follower code because if the robot traveled too fast it was more likely to drift and hit the wall. Again, I solved these problems through a ton of trial and error. 

## Future Work
If I had more time there are a number of things I would want to change about my wall follower and my person follower. (I don't think there is much I could do to improve my drive in square, besides use the odometry instead of timing). My wall follower still travels pretty slowly because I was unable to increase the speed without it veering away from the wall (it seems like the noise is more pronounced at higher speeds). I think I could make the robot go faster with different constants for my proportional control but I was unable to find these. Additionally it takes some time for my robot to navigate corners, as it has to stop to turn. I would be interested if I could make it travel the corners without stopping, and instead cut them in a smooth path. I was unable to think of a concise way to do this while writing the code. For the person follower, I'd also be interested in trying to make the robot go faster, as my only attempts at increasing the speed tended to take the robot very far off course. I was also thinking of how I could get the robot to travel faster when it is aligned well with the object (i.e., the angle to the closest object is close to 0). I wasn't sure what functional form this might take but I think this could conceptually allow me to go faster without the robot going so far off course. 

## Takeaways
* This kind of work involves a ton of trial and error. I encountered this the most when I was trying to pick robot speeds, constants of proportionality, and "buffer" distances and angles. There really seemed like there was no good way to check whether certain values would work besides trying different values and seeing how the robot responded. What seemed to generally work were small constants of proportionality (around 0.01 for angles, and 0.5 for distances). Starting out with small speeds and large buffers also seems like a good approach. Of course, while I may have a better idea of starting guesses, there really is no way to know for sure without trying them. 
* It is more helpful to try to think of simple solutions to these kinds of behaviors then immediately dive into a convoluted argument. This is something I really felt with my wall follower behavior. I still feel like that code is not as concise as it could be (in terms of logic), but it has definitely improved from the early stages of my writing it. When it felt like it was getting too complicated and I had no idea how to resolve my bugs, I stopped looking at the code and instead just tried thinking about different scenarios and what the robot should do in them on paper. This helped me to realize why the robot was getting stuck in the corner and perform the simple check of how close the wall in front of the robot was. Maybe in the future it would be better to start thinking about these problems on paper or pseudocode than just trying to code off the top of my head. 

